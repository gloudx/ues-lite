// –ü—Ä–∏–º–µ—Ä 1: –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –≤—Å–µ—Ö —Å–æ–±—ã—Ç–∏–π
// ues-ds subscribe logger --file=logger.js

console.log('Event logger started');

// –õ–æ–≥–∏—Ä—É–µ–º –≤—Å–µ —Å–æ–±—ã—Ç–∏—è —Å –ø–æ–¥—Ä–æ–±–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π
console.log('='.repeat(50));
console.log('Event Type:', event.type);
console.log('Key:', event.key);
console.log('Value Length:', event.value ? event.value.length : 0);
console.log('Timestamp:', new Date(event.timestamp * 1000).toISOString());

// –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —á–∞—Å—Ç–∏ –∫–ª—é—á–∞
if (event.metadata) {
    console.log('Key Parts:');
    for (let key in event.metadata) {
        if (key.startsWith('key_part_')) {
            console.log('  -', event.metadata[key]);
        }
    }
}

// –ü—Ä–µ–≤—å—é –∑–Ω–∞—á–µ–Ω–∏—è –¥–ª—è —Ç–µ–∫—Å—Ç–æ–≤—ã—Ö –¥–∞–Ω–Ω—ã—Ö
if (event.value && event.value.length > 0) {
    try {
        const parsed = JSON.parse(event.value);
        console.log('JSON Value Preview:', JSON.stringify(parsed, null, 2).substring(0, 200));
    } catch (e) {
        console.log('Text Value Preview:', event.value.substring(0, 100));
    }
}

//==============================================================================
// –ü—Ä–∏–º–µ—Ä 2: Webhook —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –¥–ª—è –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏—Ö —Å–æ–±—ã—Ç–∏–π
// ues-ds subscribe webhook --file=webhook.js --events=put --events=delete

const WEBHOOK_URL = 'https://hooks.slack.com/services/YOUR/SLACK/WEBHOOK';
const CRITICAL_PREFIXES = ['/config/', '/users/', '/admin/'];

// –ü—Ä–æ–≤–µ—Ä—è–µ–º, –∫—Ä–∏—Ç–∏—á–µ–Ω –ª–∏ —ç—Ç–æ—Ç –∫–ª—é—á
const isCritical = CRITICAL_PREFIXES.some(prefix => event.key.startsWith(prefix));

if (isCritical) {
    console.log('Critical event detected:', event.key);
    
    let message = '';
    let color = 'good';
    
    switch (event.type) {
        case 'put':
            message = `üîÑ Updated key: ${event.key}`;
            color = 'warning';
            break;
        case 'delete':
            message = `üóëÔ∏è Deleted key: ${event.key}`;
            color = 'danger';
            break;
        default:
            message = `üìù Event ${event.type} on key: ${event.key}`;
    }
    
    const payload = {
        text: 'UES Datastore Alert',
        attachments: [{
            color: color,
            fields: [{
                title: 'Event Details',
                value: message,
                short: false
            }, {
                title: 'Timestamp',
                value: new Date(event.timestamp * 1000).toISOString(),
                short: true
            }, {
                title: 'Server',
                value: 'production-server-1',
                short: true
            }]
        }]
    };
    
    try {
        const response = HTTP.post(WEBHOOK_URL, payload);
        if (response.status === 200) {
            console.log('Webhook notification sent successfully');
        } else {
            console.error('Webhook failed:', response.status, response.body);
        }
    } catch (error) {
        console.error('Webhook error:', error);
    }
}

//==============================================================================
// –ü—Ä–∏–º–µ—Ä 3: –ê—É–¥–∏—Ç –∏ —Ä–µ–∑–µ—Ä–≤–Ω–æ–µ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ
// ues-ds subscribe backup --file=backup.js

const BACKUP_API = 'https://backup.example.com/api/v1/store';
const API_TOKEN = 'your-api-token-here';

// –°–æ–∑–¥–∞–µ–º –∑–∞–ø–∏—Å—å –∞—É–¥–∏—Ç–∞
const auditRecord = {
    event_id: Crypto.sha256(event.key + event.timestamp),
    timestamp: event.timestamp,
    event_type: event.type,
    key: event.key,
    value_hash: event.value ? Crypto.sha256(event.value) : null,
    value_size: event.value ? event.value.length : 0,
    server_id: 'prod-01',
    user_agent: 'ues-ds/1.1.0'
};

console.log('Creating audit record:', auditRecord.event_id);

// –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤ —Å–∏—Å—Ç–µ–º—É –∞—É–¥–∏—Ç–∞
try {
    const response = HTTP.post(BACKUP_API, auditRecord, {
        headers: {
            'Authorization': 'Bearer ' + API_TOKEN,
            'Content-Type': 'application/json'
        }
    });
    
    if (response.status >= 200 && response.status < 300) {
        console.log('Audit record stored successfully');
    } else {
        console.error('Audit storage failed:', response.status);
    }
} catch (error) {
    console.error('Audit error:', error);
}

// –î–ª—è –≤–∞–∂–Ω—ã—Ö –∫–ª—é—á–µ–π —Ç–∞–∫–∂–µ —Å–æ–∑–¥–∞–µ–º —Ä–µ–∑–µ—Ä–≤–Ω—É—é –∫–æ–ø–∏—é
const IMPORTANT_PATTERNS = ['/config/', '/schema/', '/migrations/'];
const shouldBackup = IMPORTANT_PATTERNS.some(pattern => event.key.includes(pattern));

if (shouldBackup && event.type === 'put') {
    console.log('Creating backup for important key:', event.key);
    
    const backupPayload = {
        key: event.key,
        value: event.value,
        timestamp: event.timestamp,
        checksum: Crypto.md5(event.value)
    };
    
    try {
        HTTP.post(BACKUP_API + '/backup', backupPayload, {
            headers: { 'Authorization': 'Bearer ' + API_TOKEN }
        });
        console.log('Backup created for:', event.key);
    } catch (error) {
        console.error('Backup failed:', error);
    }
}

//==============================================================================
// –ü—Ä–∏–º–µ—Ä 4: –ö–µ—à-–∏–Ω–≤–∞–ª–∏–¥–∞—Ü–∏—è
// ues-ds subscribe cache --file=cache_invalidator.js

const REDIS_API = 'http://redis-api.internal/v1';
const CACHE_PATTERNS = {
    '/users/': 'user_cache:*',
    '/config/': 'config_cache:*',
    '/api/': 'api_cache:*'
};

console.log('Cache invalidation trigger for:', event.key);

// –û–ø—Ä–µ–¥–µ–ª—è–µ–º, –∫–∞–∫–∏–µ –∫–µ—à–∏ –Ω—É–∂–Ω–æ –∏–Ω–≤–∞–ª–∏–¥–∏—Ä–æ–≤–∞—Ç—å
const cachesToInvalidate = [];

for (const [keyPattern, cachePattern] of Object.entries(CACHE_PATTERNS)) {
    if (event.key.startsWith(keyPattern)) {
        cachesToInvalidate.push({
            pattern: cachePattern,
            reason: `Key ${event.key} was ${event.type}`
        });
    }
}

// –ò–Ω–≤–∞–ª–∏–¥–∏—Ä—É–µ–º –Ω–∞–π–¥–µ–Ω–Ω—ã–µ –∫–µ—à–∏
for (const cache of cachesToInvalidate) {
    console.log('Invalidating cache pattern:', cache.pattern);
    
    try {
        const response = HTTP.post(REDIS_API + '/invalidate', {
            pattern: cache.pattern,
            reason: cache.reason,
            timestamp: event.timestamp
        });
        
        if (response.status === 200) {
            const result = JSON.parse(response.body);
            console.log(`Invalidated ${result.keys_deleted} cache entries`);
        }
    } catch (error) {
        console.error('Cache invalidation error:', error);
    }
}

//==============================================================================
// –ü—Ä–∏–º–µ—Ä 5: –ú–µ—Ç—Ä–∏–∫–∏ –∏ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥
// ues-ds subscribe metrics --file=metrics.js

const METRICS_ENDPOINT = 'http://prometheus-pushgateway:9091/metrics/job/ues_datastore';

// –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ–º –º–µ—Ç—Ä–∏–∫–∏
const timestamp = Math.floor(Date.now() / 1000);
const labels = {
    instance: 'ues-ds-prod-01',
    event_type: event.type,
    key_prefix: event.key.split('/')[1] || 'root'
};

let metricsData = '';

// –°—á–µ—Ç—á–∏–∫ —Å–æ–±—ã—Ç–∏–π
metricsData += `ues_datastore_events_total{`;
metricsData += Object.entries(labels).map(([k, v]) => `${k}="${v}"`).join(',');
metricsData += `} 1 ${timestamp}\n`;

// –†–∞–∑–º–µ—Ä –∑–Ω–∞—á–µ–Ω–∏—è
if (event.value) {
    metricsData += `ues_datastore_value_bytes{`;
    metricsData += Object.entries(labels).map(([k, v]) => `${k}="${v}"`).join(',');
    metricsData += `} ${event.value.length} ${timestamp}\n`;
}

// –ì–ª—É–±–∏–Ω–∞ –∫–ª—é—á–∞
const keyDepth = event.key.split('/').length - 1;
metricsData += `ues_datastore_key_depth{`;
metricsData += Object.entries(labels).map(([k, v]) => `${k}="${v}"`).join(',');
metricsData += `} ${keyDepth} ${timestamp}\n`;

// –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –º–µ—Ç—Ä–∏–∫–∏
try {
    const response = HTTP.post(METRICS_ENDPOINT, metricsData, {
        headers: {
            'Content-Type': 'text/plain'
        }
    });
    
    if (response.status === 200) {
        console.log('Metrics sent successfully');
    } else {
        console.error('Metrics push failed:', response.status);
    }
} catch (error) {
    console.error('Metrics error:', error);
}

//==============================================================================
// –ü—Ä–∏–º–µ—Ä 6: –í–∞–ª–∏–¥–∞—Ü–∏—è –¥–∞–Ω–Ω—ã—Ö –∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ–± –æ—à–∏–±–∫–∞—Ö
// ues-ds subscribe validator --file=validator.js --events=put

console.log('Validating data for key:', event.key);

// –°—Ö–µ–º—ã –≤–∞–ª–∏–¥–∞—Ü–∏–∏ –¥–ª—è —Ä–∞–∑–Ω—ã—Ö —Ç–∏–ø–æ–≤ –∫–ª—é—á–µ–π
const VALIDATION_SCHEMAS = {
    '/users/': {
        required: ['name', 'email'],
        types: {
            name: 'string',
            email: 'string',
            age: 'number'
        },
        patterns: {
            email: /^[^\s@]+@[^\s@]+\.[^\s@]+$/
        }
    },
    '/config/': {
        required: ['value'],
        maxSize: 1024 * 10 // 10KB max
    }
};

let validationResult = { valid: true, errors: [] };

// –ù–∞—Ö–æ–¥–∏–º –ø–æ–¥—Ö–æ–¥—è—â—É—é —Å—Ö–µ–º—É
for (const [prefix, schema] of Object.entries(VALIDATION_SCHEMAS)) {
    if (event.key.startsWith(prefix)) {
        validationResult = validateData(event.value, schema);
        break;
    }
}

function validateData(value, schema) {
    const result = { valid: true, errors: [] };
    
    if (!value) {
        result.errors.push('Empty value');
        result.valid = false;
        return result;
    }
    
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ä–∞–∑–º–µ—Ä–∞
    if (schema.maxSize && value.length > schema.maxSize) {
        result.errors.push(`Value too large: ${value.length} > ${schema.maxSize}`);
        result.valid = false;
    }
    
    // –ü–æ–ø—ã—Ç–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ JSON
    let data;
    try {
        data = JSON.parse(value);
    } catch (e) {
        result.errors.push('Invalid JSON format');
        result.valid = false;
        return result;
    }
    
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã—Ö –ø–æ–ª–µ–π
    if (schema.required) {
        for (const field of schema.required) {
            if (!(field in data)) {
                result.errors.push(`Missing required field: ${field}`);
                result.valid = false;
            }
        }
    }
    
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç–∏–ø–æ–≤
    if (schema.types) {
        for (const [field, expectedType] of Object.entries(schema.types)) {
            if (field in data && typeof data[field] !== expectedType) {
                result.errors.push(`Invalid type for ${field}: expected ${expectedType}`);
                result.valid = false;
            }
        }
    }
    
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–∞—Ç—Ç–µ—Ä–Ω–æ–≤
    if (schema.patterns) {
        for (const [field, pattern] of Object.entries(schema.patterns)) {
            if (field in data && !pattern.test(data[field])) {
                result.errors.push(`Invalid format for ${field}`);
                result.valid = false;
            }
        }
    }
    
    return result;
}

// –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –≤–∞–ª–∏–¥–∞—Ü–∏–∏
if (!validationResult.valid) {
    console.error('Validation failed for key:', event.key);
    console.error('Errors:', validationResult.errors);
    
    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ
    const errorPayload = {
        severity: 'error',
        service: 'ues-datastore',
        message: 'Data validation failed',
        details: {
            key: event.key,
            errors: validationResult.errors,
            timestamp: event.timestamp
        }
    };
    
    try {
        HTTP.post('https://alerts.example.com/api/alert', errorPayload);
        console.log('Error alert sent');
    } catch (error) {
        console.error('Failed to send error alert:', error);
    }
} else {
    console.log('Validation passed for key:', event.key);
}

//==============================================================================
// –ü—Ä–∏–º–µ—Ä 7: –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è —Å –≤–Ω–µ—à–Ω–∏–º–∏ —Å–∏—Å—Ç–µ–º–∞–º–∏
// ues-ds subscribe sync --file=external_sync.js

const EXTERNAL_APIS = {
    '/users/': {
        url: 'https://api.external-crm.com/users',
        auth: 'Bearer token-here',
        method: 'PUT'
    },
    '/products/': {
        url: 'https://api.inventory.com/products',
        auth: 'Bearer token-here',
        method: 'POST'
    }
};

console.log('Checking if external sync needed for:', event.key);

// –ù–∞—Ö–æ–¥–∏–º —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–π –≤–Ω–µ—à–Ω–∏–π API
for (const [prefix, apiConfig] of Object.entries(EXTERNAL_APIS)) {
    if (event.key.startsWith(prefix) && event.type === 'put') {
        console.log('Syncing to external API:', apiConfig.url);
        
        try {
            // –ò–∑–≤–ª–µ–∫–∞–µ–º ID –∏–∑ –∫–ª—é—á–∞
            const keyParts = event.key.split('/');
            const entityId = keyParts[keyParts.length - 1];
            
            // –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ–º –¥–∞–Ω–Ω—ã–µ
            let syncData;
            try {
                syncData = JSON.parse(event.value);
                syncData.id = entityId;
                syncData.lastModified = event.timestamp;
            } catch (e) {
                console.error('Cannot parse value for sync:', e);
                continue;
            }
            
            // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ
            const response = HTTP.request(apiConfig.method, apiConfig.url + '/' + entityId, {
                headers: {
                    'Authorization': apiConfig.auth,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(syncData)
            });
            
            if (response.status >= 200 && response.status < 300) {
                console.log('Successfully synced to external API');
            } else {
                console.error('External API sync failed:', response.status, response.body);
            }
            
        } catch (error) {
            console.error('Sync error:', error);
        }
        
        break;
    }
}

//==============================================================================
// –ü—Ä–∏–º–µ—Ä 8: –ê–≥—Ä–µ–≥–∞—Ü–∏—è –∏ –∞–Ω–∞–ª–∏—Ç–∏–∫–∞
// ues-ds subscribe analytics --file=analytics.js

const ANALYTICS_BUFFER = [];
const ANALYTICS_API = 'https://analytics.example.com/api/events';

// –°–æ–∑–¥–∞–µ–º –∞–Ω–∞–ª–∏—Ç–∏—á–µ—Å–∫–æ–µ —Å–æ–±—ã—Ç–∏–µ
const analyticsEvent = {
    event_id: Crypto.sha256(event.key + event.timestamp + Math.random()),
    timestamp: event.timestamp,
    type: 'datastore_event',
    properties: {
        operation: event.type,
        key: event.key,
        key_segments: event.key.split('/').filter(s => s.length > 0),
        value_size: event.value ? event.value.length : 0,
        has_json_value: event.value ? isValidJSON(event.value) : false
    },
    context: {
        source: 'ues-datastore',
        version: '1.1.0',
        server: 'production'
    }
};

function isValidJSON(str) {
    try {
        JSON.parse(str);
        return true;
    } catch (e) {
        return false;
    }
}

// –î–æ–±–∞–≤–ª—è–µ–º —Å–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã–µ —Å–≤–æ–π—Å—Ç–≤–∞ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ç–∏–ø–∞ –∫–ª—é—á–∞
if (event.key.startsWith('/users/')) {
    analyticsEvent.properties.category = 'user_management';
} else if (event.key.startsWith('/config/')) {
    analyticsEvent.properties.category = 'configuration';
} else if (event.key.startsWith('/api/')) {
    analyticsEvent.properties.category = 'api_data';
}

console.log('Analytics event created:', analyticsEvent.event_id);

// –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–±—ã—Ç–∏–µ (–º–æ–∂–Ω–æ –±–∞—Ç—á–∏—Ç—å –¥–ª—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏)
try {
    const response = HTTP.post(ANALYTICS_API, analyticsEvent);
    
    if (response.status === 200 || response.status === 202) {
        console.log('Analytics event sent successfully');
    } else {
        console.error('Analytics API error:', response.status);
    }
} catch (error) {
    console.error('Analytics error:', error);
}

//==============================================================================
// –ü—Ä–∏–º–µ—Ä –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è —É—Ç–∏–ª–∏—Ç

// –†–∞–±–æ—Ç–∞ —Å–æ —Å—Ç—Ä–æ–∫–∞–º–∏
const keyParts = Strings.split(event.key, '/');
const cleanKey = Strings.trim(event.key);
const isUserKey = Strings.hasPrefix(event.key, '/users/');

// –†–∞–±–æ—Ç–∞ —Å –≤—Ä–µ–º–µ–Ω–µ–º
const eventTime = Time.format(event.timestamp, '2006-01-02 15:04:05');
const hourAgo = Time.now() - 3600;

// –ö—Ä–∏–ø—Ç–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∏–µ —Ñ—É–Ω–∫—Ü–∏–∏
const keyHash = Crypto.sha256(event.key);
const contentHash = event.value ? Crypto.md5(event.value) : null;

console.log('Key:', cleanKey);
console.log('Hash:', keyHash);
console.log('Time:', eventTime);
console.log('Is User Key:', isUserKey);
package indexer

import (
	"context"
	"errors"
	"fmt"
	"sort"
	"sync"

	"github.com/ipfs/go-cid"
	"github.com/ipld/go-ipld-prime/datamodel"
	cidlink "github.com/ipld/go-ipld-prime/linking/cid"
	"github.com/ipld/go-ipld-prime/node/basicnode"

	"ues/blockstore"
	"ues/mst"
)

// Index управляет корневыми узлами MST для каждой коллекции и предоставляет операции
// с записями в рамках конкретных коллекций. Индекс является центральным компонентом
// репозитория, который организует данные в виде именованных коллекций, каждая из которых
// представлена отдельным MST (Merkle Search Tree).
//
// Архитектура индекса:
// - Каждая коллекция имеет свой собственный MST корень
// - Индекс материализуется как IPLD узел-карта: collection_name -> MST_root_CID
// - Пустые коллекции представлены как null значения в карте
// - Все изменения отслеживаются в памяти до материализации
//
// Потокобезопасность:
// - Используется RWMutex для безопасного параллельного доступа
// - Операции чтения могут выполняться параллельно
// - Операции записи блокируют все остальные операции
//
// Компоненты:
//   - bs: блочное хранилище для сохранения узлов индекса и MST
//   - roots: карта имен коллекций на CID их корневых MST узлов
//   - root: CID материализованного узла индекса (карта коллекций)
//   - mu: мьютекс для обеспечения потокобезопасности
type Index struct {
	bs    blockstore.Blockstore
	mu    sync.RWMutex
	root  cid.Cid            // CID of materialized index node (map of collections)
	roots map[string]cid.Cid // collection name -> MST root
}

// NewIndex создает новый пустой индекс, поддерживаемый указанным блочным хранилищем.
// Индекс инициализируется без коллекций и готов к добавлению новых коллекций
// и записей.
//
// Параметры:
//   - bs: блочное хранилище для сохранения узлов индекса и MST структур
//
// Возвращает:
//   - *Index: новый экземпляр индекса в пустом состоянии
//
// Начальное состояние:
// - roots: пустая карта коллекций
// - root: cid.Undef (индекс не материализован)
// - готов к операциям создания коллекций и добавления записей
func NewIndex(bs blockstore.Blockstore, root cid.Cid) *Index {
	return &Index{
		bs:    bs,
		root:  root,
		roots: make(map[string]cid.Cid),
	}
}

// Load устанавливает состояние индекса из материализованного корневого CID индекса.
// Этот метод восстанавливает полное состояние индекса, включая все коллекции и их
// MST корни, из ранее сохраненного узла индекса. Используется при загрузке
// существующего репозитория или восстановлении после перезапуска.
//
// Параметры:
//   - ctx: контекст для отмены операции и передачи значений
//   - root: CID узла индекса для загрузки. Если cid.Undef, индекс сбрасывается в пустое состояние
//
// Возвращает:
//   - error: ошибка загрузки, если узел не найден или имеет некорректную структуру
//
// Структура узла индекса:
//
//	{
//	  "collection1": <ссылка на MST корень> или null,
//	  "collection2": <ссылка на MST корень> или null,
//	  ...
//	}
//
// Процесс загрузки:
// 1. Сброс текущего состояния индекса
// 2. Если root не определен - остаться в пустом состоянии
// 3. Загрузка узла индекса из blockstore
// 4. Итерация по карте коллекций
// 5. Извлечение CID корня MST для каждой коллекции
// 6. Обновление внутренней карты roots
//
// Потокобезопасность: метод блокирует индекс на запись на время загрузки
func (i *Index) Load(ctx context.Context) error {
	// Блокируем индекс для записи на время загрузки
	// Это гарантирует атомарность операции восстановления состояния
	i.mu.Lock()
	defer i.mu.Unlock()

	// === Обработка пустого индекса ===
	// Если root не определен, оставляем индекс в пустом состоянии
	// Это нормальное состояние для нового репозитория без коллекций
	if !i.root.Defined() {
		return nil
	}

	// Сбрасываем карту корней коллекций для чистого состояния
	// Это важно при повторной загрузке поверх существующего состояния
	i.roots = make(map[string]cid.Cid)

	// === Загрузка узла индекса из blockstore ===
	// Получаем IPLD узел индекса по его CID
	// Узел должен быть картой: collection_name -> MST_root_link
	dm, err := i.bs.GetNode(ctx, i.root)
	if err != nil {
		// Если узел не найден или не может быть десериализован,
		// возвращаем ошибку с контекстом операции
		return fmt.Errorf("index: load root node: %w", err)
	}

	// === Итерация по карте коллекций ===
	// Получаем итератор для обхода всех пар ключ-значение в карте
	it := dm.MapIterator()
	for !it.Done() {
		// Получаем следующую пару ключ-значение из карты
		k, v, err := it.Next()
		if err != nil {
			// Если итерация не удалась (поврежденные данные),
			// прерываем загрузку с ошибкой
			return fmt.Errorf("index: iterate map: %w", err)
		}

		// === Извлечение имени коллекции ===
		// Ключ должен быть строкой - именем коллекции
		name, err := k.AsString()
		if err != nil {
			// Если ключ не является строкой, структура индекса нарушена
			return fmt.Errorf("index: invalid key type: %w", err)
		}

		// === Обработка значения коллекции ===
		// Значение может быть null (пустая коллекция) или ссылкой на MST корень
		if v.IsNull() {
			// Пустая коллекция представлена как null
			// Сохраняем cid.Undef для обозначения отсутствия MST
			i.roots[name] = cid.Undef
			continue
		}

		// === Извлечение ссылки на MST корень ===
		// Значение должно быть ссылкой на CID корневого узла MST
		lnk, err := v.AsLink()
		if err != nil {
			// Если значение не null и не ссылка, структура нарушена
			return fmt.Errorf("index: value is not link: %w", err)
		}

		// Приводим общий тип Link к конкретному cidlink.Link
		cl, ok := lnk.(cidlink.Link)
		if !ok {
			// Если тип ссылки неожиданный, сообщаем об ошибке
			return errors.New("index: unexpected link type")
		}

		// Сохраняем CID корня MST для данной коллекции
		// Теперь коллекция может использоваться для операций с записями
		i.roots[name] = cl.Cid
	}

	// Загрузка завершена успешно, индекс готов к работе
	return nil
}

// Root возвращает CID материализованного узла индекса.
// Этот метод предоставляет доступ к CID корневого узла индекса, который
// содержит карту всех коллекций и их MST корней. CID может быть cid.Undef,
// если индекс еще не был материализован или находится в пустом состоянии.
//
// Возвращает:
//   - cid.Cid: CID узла индекса или cid.Undef для пустого/неинициализированного индекса
//
// Использование:
//
//	rootCID := index.Root()
//	if rootCID.Defined() {
//	    // индекс материализован и может быть сохранен/передан
//	}
//
// Потокобезопасность: использует RLock для безопасного чтения в многопоточной среде
func (i *Index) Root() cid.Cid {
	// Используем блокировку чтения для безопасного доступа к полю root
	// RLock позволяет множественным читателям работать параллельно
	i.mu.RLock()
	defer i.mu.RUnlock()
	return i.root
}

// materialize перестраивает и сохраняет узел индекса из текущей карты корней.
// Этот внутренний метод создает IPLD узел-карту, содержащую все коллекции и их
// MST корни, сериализует его и сохраняет в blockstore. Материализация необходима
// для создания постоянной ссылки на текущее состояние индекса.
//
// Параметры:
//   - ctx: контекст для отмены операции и передачи значений
//
// Возвращает:
//   - cid.Cid: CID нового материализованного узла индекса
//   - error: ошибка создания или сохранения узла
//
// Процесс материализации:
// 1. Создание снимка имен коллекций для детерминированного порядка
// 2. Сортировка имен коллекций для обеспечения воспроизводимости CID
// 3. Построение IPLD узла-карты collection_name -> MST_root_link/null
// 4. Сохранение узла в blockstore и получение его CID
// 5. Обновление внутреннего поля root
//
// Детерминизм: сортировка ключей гарантирует одинаковый CID для одинакового содержимого
// Потокобезопасность: использует кратковременные блокировки для чтения состояния
func (i *Index) materialize(ctx context.Context) (cid.Cid, error) {
	// === Создание детерминированного снимка коллекций ===
	// Получаем список имен всех коллекций для сортировки
	// Кратковременная блокировка чтения для снимка ключей
	i.mu.RLock()
	keys := make([]string, 0, len(i.roots))
	for k := range i.roots {
		keys = append(keys, k)
	}
	i.mu.RUnlock()

	// Сортируем имена коллекций для детерминированного порядка
	// Это гарантирует, что одинаковое содержимое даст одинаковый CID
	sort.Strings(keys)

	// === Построение IPLD узла-карты ===
	// Создаем билдер для карты с известным количеством элементов
	b := basicnode.Prototype.Map.NewBuilder()
	ma, err := b.BeginMap(int64(len(keys)))
	if err != nil {
		return cid.Undef, err
	}

	// Добавляем каждую коллекцию в карту: name -> link/null
	for _, name := range keys {
		// Создаем запись в карте для данной коллекции
		entry, err := ma.AssembleEntry(name)
		if err != nil {
			return cid.Undef, err
		}

		// Получаем текущий корень MST для коллекции
		// Используем блокировку чтения для безопасного доступа
		i.mu.RLock()
		root := i.roots[name]
		i.mu.RUnlock()

		// === Установка значения для коллекции ===
		if root.Defined() {
			// Если MST корень определен, создаем ссылку на него
			// cidlink.Link оборачивает CID в формат, понятный IPLD
			if err := entry.AssignLink(cidlink.Link{Cid: root}); err != nil {
				return cid.Undef, err
			}
		} else {
			// Если MST корень неопределен (пустая коллекция), устанавливаем null
			// null значения представляют пустые коллекции в материализованном индексе
			if err := entry.AssignNull(); err != nil {
				return cid.Undef, err
			}
		}
	}

	// Завершаем построение карты
	if err := ma.Finish(); err != nil {
		return cid.Undef, err
	}

	// === Сохранение узла в blockstore ===
	// Строим финальный IPLD узел из билдера
	n := b.Build()

	// Сериализуем и сохраняем узел в блочном хранилище
	// blockstore автоматически вычисляет CID на основе содержимого
	c, err := i.bs.PutNode(ctx, n)
	if err != nil {
		return cid.Undef, err
	}

	// === Обновление внутреннего состояния ===
	// Блокируем индекс для записи и обновляем поле root
	i.mu.Lock()
	i.root = c
	i.mu.Unlock()

	// Возвращаем CID материализованного узла индекса
	return c, nil
}

// CreateCollection регистрирует новую пустую коллекцию в индексе.
// Этот метод добавляет новую коллекцию с указанным именем и пустым MST
// (представленным как cid.Undef) в индекс. После создания коллекция готова
// для добавления записей.
//
// Параметры:
//   - ctx: контекст для отмены операции и передачи значений
//   - name: имя новой коллекции (должно быть уникальным в рамках индекса)
//
// Возвращает:
//   - cid.Cid: CID материализованного узла индекса после добавления коллекции
//   - error: ошибка создания, если коллекция уже существует или материализация не удалась
//
// Поведение:
// - Если коллекция уже существует: возвращает ошибку без изменений
// - Если коллекция новая: добавляет её с пустым MST и материализует индекс
//
// Использование:
//
//	rootCID, err := index.CreateCollection(ctx, "posts")
//	if err != nil {
//	    // обработка ошибки (например, коллекция уже существует)
//	}
//	// коллекция "posts" готова для добавления записей
//
// Атомарность: операция либо полностью успешна, либо не вносит изменений
func (i *Index) CreateCollection(ctx context.Context, name string) (cid.Cid, error) {
	// Блокируем индекс для записи на время проверки и создания коллекции
	i.mu.Lock()

	// === Проверка существования коллекции ===
	// Проверяем, не существует ли уже коллекция с таким именем
	if _, exists := i.roots[name]; exists {
		// Если коллекция существует, освобождаем блокировку и возвращаем ошибку
		i.mu.Unlock()
		return i.root, fmt.Errorf("collection already exists: %s", name)
	}

	// === Создание новой пустой коллекции ===
	// Добавляем коллекцию с неопределенным MST корнем (пустая коллекция)
	// cid.Undef представляет пустое MST, которое не имеет узлов
	i.roots[name] = cid.Undef

	// Освобождаем блокировку после обновления карты корней
	i.mu.Unlock()

	// === Материализация обновленного индекса ===
	// Создаем новый узел индекса, включающий новую коллекцию
	// materialize() создает IPLD узел и сохраняет его в blockstore
	return i.materialize(ctx)
}

// DeleteCollection удаляет запись коллекции из индекса (блоки MST остаются в blockstore).
// Этот метод удаляет коллекцию из индекса, делая её недоступной для дальнейших операций.
// Важно отметить, что сами блоки MST и записи остаются в blockstore и могут быть
// недоступны для сборки мусора.
//
// Параметры:
//   - ctx: контекст для отмены операции и передачи значений
//   - name: имя коллекции для удаления из индекса
//
// Возвращает:
//   - cid.Cid: CID материализованного узла индекса после удаления коллекции
//   - error: ошибка удаления, если коллекция не найдена или материализация не удалась
//
// Поведение:
// - Если коллекция не существует: возвращает ошибку без изменений
// - Если коллекция существует: удаляет её из карты и материализует новый индекс
//
// Важно: данные MST остаются в blockstore, только ссылка из индекса удаляется
// Использование: для окончательного удаления коллекций из репозитория
func (i *Index) DeleteCollection(ctx context.Context, name string) (cid.Cid, error) {
	// Блокируем индекс для записи на время проверки и удаления коллекции
	i.mu.Lock()

	// === Проверка существования коллекции ===
	// Проверяем, существует ли коллекция с указанным именем
	if _, exists := i.roots[name]; !exists {
		// Если коллекция не существует, освобождаем блокировку и возвращаем ошибку
		i.mu.Unlock()
		return i.root, fmt.Errorf("collection not found: %s", name)
	}

	// === Удаление коллекции из карты ===
	// Удаляем запись коллекции из внутренней карты корней
	// После этого коллекция становится недоступной через индекс
	delete(i.roots, name)

	// Освобождаем блокировку после обновления карты
	i.mu.Unlock()

	// === Материализация обновленного индекса ===
	// Создаем новый узел индекса без удаленной коллекции
	// materialize() обновляет узел индекса в blockstore
	return i.materialize(ctx)
}

// HasCollection возвращает true, если коллекция существует в индексе.
// Этот метод выполняет быструю проверку наличия коллекции с указанным именем
// в текущем индексе без загрузки или материализации данных.
//
// Параметры:
//   - name: имя коллекции для проверки существования
//
// Возвращает:
//   - bool: true, если коллекция существует; false в противном случае
//
// Использование:
//
//	if index.HasCollection("posts") {
//	    // коллекция "posts" существует и готова к использованию
//	}
//
// Производительность: O(1) - быстрая проверка в карте
// Потокобезопасность: использует RLock для безопасного чтения
func (i *Index) HasCollection(name string) bool {
	// Используем блокировку чтения для безопасного доступа к карте корней
	i.mu.RLock()
	defer i.mu.RUnlock()

	// Проверяем наличие коллекции в карте корней
	// Возвращаем true, если ключ существует (независимо от значения)
	_, ok := i.roots[name]
	return ok
}

// Collections возвращает отсортированный список имен коллекций.
// Этот метод предоставляет полный список всех коллекций, зарегистрированных
// в индексе, отсортированный в лексикографическом порядке для предсказуемости.
//
// Возвращает:
//   - []string: срез имен всех коллекций, отсортированный по алфавиту
//
// Особенности:
// - Возвращает копию данных, безопасную для модификации
// - Включает как пустые, так и непустые коллекции
// - Порядок детерминирован и воспроизводим
//
// Использование:
//
//	collections := index.Collections()
//	for _, name := range collections {
//	    fmt.Printf("Collection: %s\n", name)
//	}
//
// Производительность: O(n log n) где n - количество коллекций
func (i *Index) Collections() []string {
	// Используем блокировку чтения для безопасного доступа к карте корней
	i.mu.RLock()

	// Создаем срез для копирования имен коллекций
	keys := make([]string, 0, len(i.roots))
	for k := range i.roots {
		keys = append(keys, k)
	}

	// Освобождаем блокировку после копирования данных
	i.mu.RUnlock()

	// Сортируем имена коллекций для детерминированного порядка
	sort.Strings(keys)

	// Возвращаем отсортированный список имен коллекций
	return keys
}

// collectionRoot возвращает корень MST для коллекции и ok=false, если коллекция не найдена.
// Этот внутренний метод предоставляет прямой доступ к CID корня MST для указанной
// коллекции без дополнительных проверок или материализации.
//
// Параметры:
//   - name: имя коллекции для получения корня MST
//
// Возвращает:
//   - cid.Cid: CID корня MST коллекции (может быть cid.Undef для пустой коллекции)
//   - bool: true, если коллекция найдена; false, если коллекция не существует
//
// Использование: внутренний метод для других операций индекса
// Потокобезопасность: использует RLock для безопасного чтения
func (i *Index) collectionRoot(name string) (cid.Cid, bool) {
	// Используем блокировку чтения для безопасного доступа к карте корней
	i.mu.RLock()
	defer i.mu.RUnlock()

	// Получаем CID корня MST для коллекции
	// Возвращаем как CID, так и флаг существования коллекции
	c, ok := i.roots[name]
	return c, ok
}

// Put сохраняет запись под collection/rkey и обновляет корень MST коллекции.
// Этот метод добавляет новую запись или обновляет существующую в указанной коллекции,
// после чего перестраивает MST коллекции и материализует обновленный индекс.
//
// Параметры:
//   - ctx: контекст для отмены операции и передачи значений
//   - collection: имя коллекции для добавления/обновления записи
//   - rkey: уникальный ключ записи в рамках коллекции
//   - value: CID содержимого записи для сохранения в MST
//
// Возвращает:
//   - cid.Cid: CID материализованного узла индекса после обновления
//   - error: ошибка операции, если коллекция не найдена или MST операция не удалась
//
// Процесс выполнения:
// 1. Проверка существования коллекции
// 2. Загрузка текущего MST коллекции
// 3. Добавление/обновление записи в MST
// 4. Обновление корня MST в карте коллекций
// 5. Материализация обновленного индекса
//
// Важно: если коллекция не существует, операция завершается с ошибкой
func (i *Index) Put(ctx context.Context, collection, rkey string, value cid.Cid) (cid.Cid, error) {
	// === Получение корня MST коллекции ===
	// Используем блокировку чтения для получения текущего корня MST
	i.mu.RLock()
	root, ok := i.roots[collection]
	i.mu.RUnlock()

	// Проверяем, существует ли указанная коллекция
	if !ok {
		// Если коллекция не найдена, возвращаем ошибку без изменений
		return i.root, fmt.Errorf("collection not found: %s", collection)
	}

	// === Загрузка и обновление MST ===
	// Создаем новый экземпляр MST дерева для работы с коллекцией
	tree := mst.NewTree(i.bs)

	// Загружаем текущее состояние MST из корневого CID
	// Если root равен cid.Undef, загружается пустое дерево
	if err := tree.Load(ctx, root); err != nil {
		return i.root, err
	}

	// Добавляем или обновляем запись в MST дереве
	// tree.Put создает новую версию дерева с обновленной записью
	newRoot, err := tree.Put(ctx, rkey, value)
	if err != nil {
		return i.root, err
	}

	// === Обновление корня коллекции ===
	// Блокируем индекс для записи и обновляем корень MST коллекции
	i.mu.Lock()
	i.roots[collection] = newRoot
	i.mu.Unlock()

	// === Материализация обновленного индекса ===
	// Создаем новый узел индекса с обновленным корнем коллекции
	// Возвращаем CID материализованного индекса
	return i.materialize(ctx)
}

// Delete удаляет запись из MST коллекции.
// Этот метод удаляет запись с указанным ключом из MST указанной коллекции,
// обновляет корень MST и материализует новый индекс. Если запись не существует,
// операция завершается без изменений.
//
// Параметры:
//   - ctx: контекст для отмены операции и передачи значений
//   - collection: имя коллекции для удаления записи
//   - rkey: ключ записи для удаления из коллекции
//
// Возвращает:
//   - cid.Cid: CID материализованного узла индекса после удаления
//   - bool: true, если запись была найдена и удалена; false, если запись не существовала
//   - error: ошибка операции, если коллекция не найдена или MST операция не удалась
//
// Поведение:
// - Если коллекция не существует: возвращает ошибку
// - Если запись не существует: возвращает false без изменений индекса
// - Если запись существует: удаляет её, обновляет MST и материализует индекс
//
// Важно: удаление из MST не удаляет сами данные из blockstore
func (i *Index) Delete(ctx context.Context, collection, rkey string) (cid.Cid, bool, error) {
	// === Получение корня MST коллекции ===
	// Используем блокировку чтения для получения текущего корня MST
	i.mu.RLock()
	root, ok := i.roots[collection]
	i.mu.RUnlock()

	// Проверяем, существует ли указанная коллекция
	if !ok {
		// Если коллекция не найдена, возвращаем ошибку без изменений
		return i.root, false, fmt.Errorf("collection not found: %s", collection)
	}

	// === Загрузка и обновление MST ===
	// Создаем новый экземпляр MST дерева для работы с коллекцией
	tree := mst.NewTree(i.bs)

	// Загружаем текущее состояние MST из корневого CID
	if err := tree.Load(ctx, root); err != nil {
		return i.root, false, err
	}

	// Удаляем запись из MST дерева
	// tree.Delete возвращает новый корень и флаг, была ли запись удалена
	newRoot, removed, err := tree.Delete(ctx, rkey)
	if err != nil {
		return i.root, false, err
	}

	// === Проверка результата удаления ===
	// Если запись не была найдена и удалена, возвращаем текущий индекс без изменений
	if !removed {
		return i.root, false, nil
	}

	// === Обновление корня коллекции ===
	// Блокируем индекс для записи и обновляем корень MST коллекции
	i.mu.Lock()
	i.roots[collection] = newRoot
	i.mu.Unlock()

	// === Материализация обновленного индекса ===
	// Создаем новый узел индекса с обновленным корнем коллекции
	c, err := i.materialize(ctx)
	return c, true, err
}

// Get разрешает CID записи по collection/rkey.
// Этот метод выполняет поиск записи в MST указанной коллекции и возвращает
// CID содержимого записи, если она найдена. Используется для получения
// ссылки на данные записи для последующей загрузки из blockstore.
//
// Параметры:
//   - ctx: контекст для отмены операции и передачи значений
//   - collection: имя коллекции для поиска записи
//   - rkey: ключ записи для поиска в коллекции
//
// Возвращает:
//   - cid.Cid: CID содержимого записи (если найдена) или cid.Undef (если не найдена)
//   - bool: true, если запись найдена; false, если запись не существует
//   - error: ошибка поиска, если коллекция не найдена или MST операция не удалась
//
// Использование:
//
//	cid, found, err := index.Get(ctx, "posts", "post123")
//	if found {
//	    node, err := blockstore.GetNode(ctx, cid)
//	    // работа с содержимым записи
//	}
//
// Производительность: O(log n) где n - количество записей в коллекции
func (i *Index) Get(ctx context.Context, collection, rkey string) (cid.Cid, bool, error) {
	// === Получение корня MST коллекции ===
	// Используем блокировку чтения для получения текущего корня MST
	i.mu.RLock()
	root, ok := i.roots[collection]
	i.mu.RUnlock()

	// Проверяем, существует ли указанная коллекция
	if !ok {
		// Если коллекция не найдена, возвращаем ошибку
		return cid.Undef, false, fmt.Errorf("collection not found: %s", collection)
	}

	// === Поиск в MST ===
	// Создаем новый экземпляр MST дерева для поиска
	tree := mst.NewTree(i.bs)

	// Загружаем текущее состояние MST из корневого CID
	if err := tree.Load(ctx, root); err != nil {
		return cid.Undef, false, err
	}

	// Выполняем поиск записи в MST дереве
	// tree.Get возвращает CID записи и флаг её существования
	return tree.Get(ctx, rkey)
}

// ListCollection возвращает все записи в коллекции, упорядоченные по rkey.
// Этот метод извлекает полный список записей из MST указанной коллекции
// в лексикографическом порядке их ключей. Возвращает структуры Entry,
// содержащие как ключи, так и CID значений.
//
// Параметры:
//   - ctx: контекст для отмены операции и передачи значений
//   - collection: имя коллекции для получения списка записей
//
// Возвращает:
//   - []mst.Entry: срез записей коллекции, упорядоченный по rkey
//   - error: ошибка получения списка, если коллекция не найдена или MST операция не удалась
//
// Структура Entry:
//
//	type Entry struct {
//	    Key   string   // rkey записи
//	    Value cid.Cid  // CID содержимого записи
//	}
//
// Особенности:
// - Пустая коллекция возвращает пустой срез (не nil)
// - Порядок записей детерминирован (лексикографический по rkey)
// - MST гарантирует эффективный обход в порядке сортировки
//
// Производительность: O(n) где n - количество записей в коллекции
func (i *Index) ListCollection(ctx context.Context, collection string) ([]mst.Entry, error) {
	// === Получение корня MST коллекции ===
	// Используем блокировку чтения для получения текущего корня MST
	i.mu.RLock()
	root, ok := i.roots[collection]
	i.mu.RUnlock()

	// Проверяем, существует ли указанная коллекция
	if !ok {
		// Если коллекция не найдена, возвращаем ошибку
		return nil, fmt.Errorf("collection not found: %s", collection)
	}

	// === Обработка пустой коллекции ===
	// Если корень MST не определен, коллекция пуста
	if !root.Defined() {
		// Возвращаем пустой срез для пустой коллекции
		return []mst.Entry{}, nil
	}

	// === Обход MST коллекции ===
	// Создаем новый экземпляр MST дерева для обхода
	tree := mst.NewTree(i.bs)

	// Загружаем текущее состояние MST из корневого CID
	if err := tree.Load(ctx, root); err != nil {
		return nil, err
	}

	// Выполняем полный обход MST с помощью Range("")
	// Пустые границы означают получение всех записей от начала до конца
	return tree.Range(ctx, "", "")
}

// CollectionRoot возвращает CID корня MST для коллекции (cid.Undef если пустая), ok=false если не найдена.
// Этот публичный метод предоставляет доступ к корневому CID MST указанной коллекции
// для внешних компонентов, которым нужен прямой доступ к структуре MST.
//
// Параметры:
//   - name: имя коллекции для получения корня MST
//
// Возвращает:
//   - cid.Cid: CID корня MST коллекции (cid.Undef для пустой коллекции)
//   - bool: true, если коллекция найдена; false, если коллекция не существует
//
// Использование:
//
//	rootCID, found := index.CollectionRoot("posts")
//	if found && rootCID.Defined() {
//	    // коллекция существует и не пуста
//	}
//
// Отличие от collectionRoot: это публичный API метод
func (i *Index) CollectionRoot(name string) (cid.Cid, bool) {
	// Делегируем вызов внутреннему методу collectionRoot
	return i.collectionRoot(name)
}

// CollectionRootHash возвращает байты хеша, хранящиеся в корневом узле MST (если определен).
// Этот метод извлекает хеш из корневого узла MST коллекции, который используется
// для быстрой проверки целостности и сравнения состояний коллекций без
// полной загрузки содержимого.
//
// Параметры:
//   - ctx: контекст для отмены операции и передачи значений
//   - name: имя коллекции для получения хеша корня
//
// Возвращает:
//   - []byte: копия байтов хеша корневого узла MST
//   - bool: true, если коллекция найдена; false, если коллекция не существует
//   - error: ошибка получения хеша, если узел поврежден или недоступен
//
// Особенности:
// - Для пустой коллекции (root == cid.Undef) возвращает nil, true, nil
// - Возвращает копию байтов хеша для безопасности
// - Хеш извлекается из поля "hash" корневого узла MST
//
// Использование: для быстрого сравнения состояний коллекций
func (i *Index) CollectionRootHash(ctx context.Context, name string) ([]byte, bool, error) {
	// Получаем корень MST для указанной коллекции
	root, ok := i.collectionRoot(name)
	if !ok {
		// Если коллекция не найдена, возвращаем ошибку
		return nil, false, fmt.Errorf("collection not found: %s", name)
	}

	// === Обработка пустой коллекции ===
	// Если корень MST не определен, коллекция пуста
	if !root.Defined() {
		// Для пустой коллекции хеш отсутствует
		return nil, true, nil
	}

	// === Загрузка корневого узла MST ===
	// Получаем узел корня MST из blockstore
	n, err := i.bs.GetNode(ctx, root)
	if err != nil {
		return nil, false, err
	}

	// === Извлечение поля "hash" ===
	// Ищем поле "hash" в корневом узле MST
	hashNode, err := n.LookupByString("hash")
	if err != nil {
		// Если поле "hash" отсутствует, узел MST поврежден
		return nil, false, fmt.Errorf("mst root missing hash: %w", err)
	}

	// Извлекаем байты хеша из узла
	b, err := hashNode.AsBytes()
	if err != nil {
		// Если поле "hash" не является байтами, узел поврежден
		return nil, false, fmt.Errorf("mst root invalid hash: %w", err)
	}

	// Возвращаем копию байтов хеша для безопасности
	// append([]byte(nil), b...) создает независимую копию
	return append([]byte(nil), b...), true, nil
}

// InclusionPath возвращает путь CID узлов от корня до позиции поиска для rkey.
// Этот метод построения пути включения (inclusion path) возвращает список CID
// всех узлов MST, которые посещаются при поиске указанного ключа от корня дерева
// до целевой позиции. Используется для создания криптографических доказательств
// включения или исключения записи.
//
// Параметры:
//   - ctx: контекст для отмены операции и передачи значений
//   - name: имя коллекции для поиска пути
//   - rkey: ключ записи для построения пути поиска
//
// Возвращает:
//   - []cid.Cid: срез CID узлов от корня до позиции поиска
//   - bool: true, если rkey существует в дереве; false, если ключ отсутствует
//   - error: ошибка построения пути, если коллекция не найдена или узлы недоступны
//
// Структура пути:
// - path[0]: корневой узел MST
// - path[1]: узел второго уровня (левый или правый потомок корня)
// - ...
// - path[n-1]: конечный узел (содержащий ключ или позицию для вставки)
//
// Использование: для построения Merkle доказательств включения/исключения
// Производительность: O(log n) где n - количество записей в коллекции
func (i *Index) InclusionPath(ctx context.Context, name, rkey string) ([]cid.Cid, bool, error) {
	// === Получение корня MST коллекции ===
	// Получаем корень MST для указанной коллекции
	root, ok := i.collectionRoot(name)
	if !ok {
		// Если коллекция не найдена, возвращаем ошибку
		return nil, false, fmt.Errorf("collection not found: %s", name)
	}

	// === Обработка пустой коллекции ===
	// Если корень MST не определен, коллекция пуста
	if !root.Defined() {
		// Для пустой коллекции путь тоже пустой
		return []cid.Cid{}, false, nil
	}

	// === Построение пути поиска ===
	// Инициализируем пустой путь для сбора CID узлов
	var path []cid.Cid
	// Начинаем поиск с корневого узла
	cur := root

	// Обходим дерево до тех пор, пока не достигнем листа или не найдем ключ
	for cur.Defined() {
		// Добавляем текущий узел к пути
		path = append(path, cur)

		// === Загрузка текущего узла ===
		// Получаем узел MST из blockstore
		dm, err := i.bs.GetNode(ctx, cur)
		if err != nil {
			return nil, false, err
		}

		// === Извлечение ключа узла ===
		// Получаем поле "key" из узла MST
		kNode, err := dm.LookupByString("key")
		if err != nil {
			return nil, false, fmt.Errorf("mst node missing key: %w", err)
		}

		// Извлекаем строковое значение ключа
		key, err := kNode.AsString()
		if err != nil {
			return nil, false, fmt.Errorf("mst node key type: %w", err)
		}

		// === Навигация по дереву ===
		// Сравниваем искомый ключ с ключом текущего узла
		switch cmp := compareStrings(rkey, key); {
		case cmp == 0:
			// Ключ найден! Возвращаем путь и true
			return path, true, nil

		case cmp < 0:
			// Искомый ключ меньше текущего - идем влево
			// maybeLink извлекает CID дочернего узла или cid.Undef если его нет
			left, _ := maybeLink(dm, "left")
			cur = left

		default:
			// Искомый ключ больше текущего - идем вправо
			right, _ := maybeLink(dm, "right")
			cur = right
		}
	}

	// Дошли до конца пути, ключ не найден
	// Возвращаем путь до позиции, где ключ должен был бы находиться
	return path, false, nil
}

// maybeLink извлекает CID ссылки из указанного поля узла или возвращает cid.Undef.
// Эта вспомогательная функция безопасно извлекает ссылку из поля IPLD узла,
// обрабатывая случаи отсутствия поля, null значений и некорректных типов.
//
// Параметры:
//   - n: IPLD узел для извлечения ссылки
//   - field: имя поля, содержащего ссылку
//
// Возвращает:
//   - cid.Cid: CID из ссылки или cid.Undef если поле отсутствует/null
//   - error: ошибка извлечения, если поле имеет некорректный тип
//
// Поведение:
// - Поле отсутствует: возвращает cid.Undef, nil
// - Поле содержит null: возвращает cid.Undef, nil
// - Поле содержит ссылку: извлекает и возвращает CID
// - Поле содержит не-ссылку: возвращает ошибку
//
// Использование: для извлечения ссылок на дочерние узлы в MST
func maybeLink(n datamodel.Node, field string) (cid.Cid, error) {
	// Пытаемся найти указанное поле в узле
	child, err := n.LookupByString(field)
	if err != nil {
		// Если поле отсутствует, трактуем как неопределенную ссылку
		// Это нормальное поведение для отсутствующих дочерних узлов
		return cid.Undef, nil
	}

	// === Обработка null значения ===
	// Проверяем, является ли значение поля null
	if child.IsNull() {
		// null означает отсутствие ссылки (нет дочернего узла)
		return cid.Undef, nil
	}

	// === Извлечение ссылки ===
	// Пытаемся преобразовать значение в ссылку
	l, err := child.AsLink()
	if err != nil {
		// Если значение не является ссылкой, возвращаем ошибку
		return cid.Undef, err
	}

	// === Приведение типа ссылки ===
	// Приводим общий тип Link к конкретному cidlink.Link
	cl, ok := l.(cidlink.Link)
	if !ok {
		// Если тип ссылки неожиданный, возвращаем ошибку
		return cid.Undef, errors.New("unexpected link type")
	}

	// Успешно извлечили CID из ссылки
	return cl.Cid, nil
}

// compareStrings выполняет лексикографическое сравнение двух строк.
// Эта вспомогательная функция реализует стандартное строковое сравнение
// и возвращает результат в виде целого числа для удобства использования
// в алгоритмах сортировки и поиска.
//
// Параметры:
//   - a: первая строка для сравнения
//   - b: вторая строка для сравнения
//
// Возвращает:
//   - int: результат сравнения
//   - 0: строки равны (a == b)
//   - -1: первая строка меньше (a < b)
//   - 1: первая строка больше (a > b)
//
// Использование: для навигации по MST дереву при поиске и вставке
// Реализация: использует встроенное сравнение строк Go
func compareStrings(a, b string) int {
	// Проверяем точное равенство строк
	if a == b {
		return 0
	}

	// Используем встроенное лексикографическое сравнение Go
	if a < b {
		return -1
	}

	// Если a не равно b и a не меньше b, то a больше b
	return 1
}

// Close освобождает ресурсы, связанные с индексом.
// Этот метод закрывает все внутренние ресурсы, такие как соединения с
// blockstore или другие используемые структуры данных. После вызова
// Close индекс становится недоступным для дальнейших операций.
//
// Возвращает:
//   - error: ошибка закрытия ресурсов, если таковая имеется
//
// Использование:
//
//	defer index.Close()
//
// Важно: после вызова Close любые дальнейшие операции с индексом приведут к ошибкам.
func (i *Index) Close() error {
	return i.bs.Close()
}
